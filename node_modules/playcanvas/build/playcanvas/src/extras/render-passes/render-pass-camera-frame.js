import { GAMMA_NONE, TONEMAP_NONE, LAYERID_SKYBOX, LAYERID_IMMEDIATE } from '../../scene/constants.js';
import { PIXELFORMAT_RGBA8, FILTER_LINEAR, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_DEPTH, FILTER_NEAREST } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { RenderPassColorGrab } from '../../scene/graphics/render-pass-color-grab.js';
import { RenderPassForward } from '../../scene/renderer/render-pass-forward.js';
import { RenderTarget } from '../../platform/graphics/render-target.js';
import { RenderPassBloom } from './render-pass-bloom.js';
import { RenderPassCompose } from './render-pass-compose.js';
import { RenderPassTAA } from './render-pass-taa.js';
import { RenderPassPrepass } from './render-pass-prepass.js';
import { RenderPassSsao } from './render-pass-ssao.js';
import { RenderingParams } from '../../scene/renderer/rendering-params.js';

class RenderPassCameraFrame extends RenderPass {
	constructor(app, options = {}) {
		super(app.graphicsDevice);
		this.app = void 0;
		this.prePass = void 0;
		this.scenePass = void 0;
		this.composePass = void 0;
		this.bloomPass = void 0;
		this.ssaoPass = void 0;
		this.taaPass = void 0;
		this._bloomEnabled = false;
		this._ssaoEnabled = false;
		this._renderTargetScale = 1;
		this.rt = null;
		this.app = app;
		this.options = this.sanitizeOptions(options);
		this.setupRenderPasses(this.options);
	}
	destroy() {
		this.sceneTexture = null;
		this.sceneDepth = null;
		if (this.rt) {
			this.rt.destroyTextureBuffers();
			this.rt.destroy();
			this.rt = null;
		}
		this.beforePasses.forEach(pass => pass.destroy());
		this.beforePasses = null;
	}
	sanitizeOptions(options) {
		const defaults = {
			camera: null,
			samples: 2,
			sceneColorMap: true,
			lastGrabLayerId: LAYERID_SKYBOX,
			lastGrabLayerIsTransparent: false,
			lastSceneLayerId: LAYERID_IMMEDIATE,
			lastSceneLayerIsTransparent: true,
			taaEnabled: false,
			bloomEnabled: false,
			ssaoEnabled: false,
			ssaoBlurEnabled: true
		};
		return Object.assign({}, defaults, options);
	}
	set renderTargetScale(value) {
		this._renderTargetScale = value;
		if (this.scenePass) {
			this.scenePass.options.scaleX = value;
			this.scenePass.options.scaleY = value;
		}
	}
	get renderTargetScale() {
		return this._renderTargetScale;
	}
	get bloomEnabled() {
		return this._bloomEnabled;
	}
	set ssaoEnabled(value) {
		if (this._ssaoEnabled !== value) {
			this._ssaoEnabled = value;
			this.composePass.ssaoTexture = value ? this.ssaoPass.ssaoTexture : null;
			this.ssaoPass.enabled = value;
		}
	}
	get ssaoEnabled() {
		return this._ssaoEnabled;
	}
	set lastMipLevel(value) {
		this.bloomPass.lastMipLevel = value;
	}
	get lastMipLevel() {
		return this.bloomPass.lastMipLevel;
	}
	setupRenderPasses(options) {
		const {
			device
		} = this;
		const cameraComponent = options.camera;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.hdrFormat = device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
		if (!cameraComponent.rendering) {
			const renderingParams = new RenderingParams();
			renderingParams.gammaCorrection = GAMMA_NONE;
			renderingParams.toneMapping = TONEMAP_NONE;
			cameraComponent.rendering = renderingParams;
		}
		this.sceneTexture = new Texture(device, {
			name: 'SceneColor',
			width: 4,
			height: 4,
			format: this.hdrFormat,
			mipmaps: false,
			minFilter: FILTER_LINEAR,
			magFilter: FILTER_LINEAR,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		this.sceneDepth = new Texture(device, {
			name: 'SceneDepth',
			width: 4,
			height: 4,
			format: PIXELFORMAT_DEPTH,
			mipmaps: false,
			minFilter: FILTER_NEAREST,
			magFilter: FILTER_NEAREST,
			addressU: ADDRESS_CLAMP_TO_EDGE,
			addressV: ADDRESS_CLAMP_TO_EDGE
		});
		this.rt = new RenderTarget({
			colorBuffer: this.sceneTexture,
			depthBuffer: this.sceneDepth,
			samples: options.samples
		});
		this.sceneOptions = {
			resizeSource: targetRenderTarget,
			scaleX: this.renderTargetScale,
			scaleY: this.renderTargetScale
		};
		this.createPasses(options);
		const allPasses = this.collectPasses();
		this.beforePasses = allPasses.filter(element => element !== undefined);
	}
	collectPasses() {
		return [this.prePass, this.ssaoPass, this.scenePass, this.colorGrabPass, this.scenePassTransparent, this.taaPass, this.bloomPass, this.composePass, this.afterPass];
	}
	createPasses(options) {
		this.setupScenePrepass(options);
		this.setupSsaoPass(options);
		const scenePassesInfo = this.setupScenePass(options);
		const sceneTextureWithTaa = this.setupTaaPass(options);
		this.setupBloomPass(options, sceneTextureWithTaa);
		this.setupComposePass(options);
		this.setupAfterPass(options, scenePassesInfo);
	}
	setupScenePrepass(options) {
		if (options.prepassEnabled) {
			const {
				app,
				device
			} = this;
			const {
				scene,
				renderer
			} = app;
			const cameraComponent = options.camera;
			this.prePass = new RenderPassPrepass(device, scene, renderer, cameraComponent, this.sceneDepth, this.sceneOptions);
		}
	}
	setupScenePass(options) {
		const {
			app,
			device
		} = this;
		const {
			scene,
			renderer
		} = app;
		const composition = scene.layers;
		const cameraComponent = options.camera;
		this.scenePass = new RenderPassForward(device, composition, scene, renderer);
		this.scenePass.init(this.rt, this.sceneOptions);
		if (options.prepassEnabled) {
			this.scenePass.noDepthClear = true;
			this.scenePass.depthStencilOps.storeDepth = true;
		}
		const lastLayerId = options.sceneColorMap ? options.lastGrabLayerId : options.lastSceneLayerId;
		const lastLayerIsTransparent = options.sceneColorMap ? options.lastGrabLayerIsTransparent : options.lastSceneLayerIsTransparent;
		const ret = {
			lastAddedIndex: 0,
			clearRenderTarget: true
		};
		ret.lastAddedIndex = this.scenePass.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, lastLayerId, lastLayerIsTransparent);
		ret.clearRenderTarget = false;
		if (options.sceneColorMap) {
			this.colorGrabPass = new RenderPassColorGrab(device);
			this.colorGrabPass.source = this.rt;
			this.scenePassTransparent = new RenderPassForward(device, composition, scene, renderer);
			this.scenePassTransparent.init(this.rt);
			ret.lastAddedIndex = this.scenePassTransparent.addLayers(composition, cameraComponent, ret.lastAddedIndex, ret.clearRenderTarget, options.lastSceneLayerId, options.lastSceneLayerIsTransparent);
			if (options.prepassEnabled) {
				this.scenePassTransparent.depthStencilOps.storeDepth = true;
			}
		}
		return ret;
	}
	setupSsaoPass(options) {
		const {
			camera,
			ssaoBlurEnabled,
			ssaoEnabled
		} = options;
		if (ssaoEnabled) {
			this.ssaoPass = new RenderPassSsao(this.device, this.sceneTexture, camera, ssaoBlurEnabled);
		}
	}
	setupBloomPass(options, inputTexture) {
		if (options.bloomEnabled) {
			this.bloomPass = new RenderPassBloom(this.device, inputTexture, this.hdrFormat);
		}
	}
	setupTaaPass(options) {
		let textureWithTaa = this.sceneTexture;
		if (options.taaEnabled) {
			const cameraComponent = options.camera;
			this.taaPass = new RenderPassTAA(this.device, this.sceneTexture, cameraComponent);
			textureWithTaa = this.taaPass.historyTexture;
		}
		return textureWithTaa;
	}
	setupComposePass(options) {
		var _this$bloomPass;
		this.composePass = new RenderPassCompose(this.device);
		this.composePass.bloomTexture = (_this$bloomPass = this.bloomPass) == null ? void 0 : _this$bloomPass.bloomTexture;
		this.composePass.taaEnabled = options.taaEnabled;
		const cameraComponent = options.camera;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.composePass.init(targetRenderTarget);
	}
	setupAfterPass(options, scenePassesInfo) {
		const {
			app
		} = this;
		const {
			scene,
			renderer
		} = app;
		const composition = scene.layers;
		const cameraComponent = options.camera;
		const targetRenderTarget = cameraComponent.renderTarget;
		this.afterPass = new RenderPassForward(this.device, composition, scene, renderer);
		this.afterPass.init(targetRenderTarget);
		this.afterPass.addLayers(composition, cameraComponent, scenePassesInfo.lastAddedIndex, scenePassesInfo.clearRenderTarget);
	}
	frameUpdate() {
		var _this$taaPass$update, _this$taaPass;
		super.frameUpdate();
		const sceneTexture = (_this$taaPass$update = (_this$taaPass = this.taaPass) == null ? void 0 : _this$taaPass.update()) != null ? _this$taaPass$update : this.rt.colorBuffer;
		this.composePass.sceneTexture = sceneTexture;
		if (this.bloomEnabled) {
			this.bloomPass.sourceTexture = sceneTexture;
		}
	}
}

export { RenderPassCameraFrame };
