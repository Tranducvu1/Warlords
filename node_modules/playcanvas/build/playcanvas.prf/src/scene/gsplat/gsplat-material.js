import { CULLFACE_NONE } from '../../platform/graphics/constants.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { DITHER_NONE, BLEND_NONE, BLEND_NORMAL } from '../constants.js';
import { ShaderMaterial } from '../materials/shader-material.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { gsplat } from './shader-generator-gsplat.js';

const splatMainVS = `
		vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);

		void main(void)
		{
				// calculate splat uv
				if (!calcSplatUV()) {
						gl_Position = discardVec;
						return;
				}

				// read data
				readData();

				vec4 pos;
				if (!evalSplat(pos)) {
						gl_Position = discardVec;
						return;
				}

				gl_Position = pos;

				texCoord = vertex_position.xy;
				color = getColor();

				#ifndef DITHER_NONE
						id = float(splatId);
				#endif
		}
`;
const splatMainFS = `
		void main(void)
		{
				gl_FragColor = evalSplat();
		}
`;
const createGSplatMaterial = (options = {}) => {
	var _options$dither;
	const ditherEnum = (_options$dither = options.dither) != null ? _options$dither : DITHER_NONE;
	const dither = ditherEnum !== DITHER_NONE;
	const material = new ShaderMaterial();
	material.name = 'splatMaterial';
	material.cull = CULLFACE_NONE;
	material.blendType = dither ? BLEND_NONE : BLEND_NORMAL;
	material.depthWrite = dither;
	material.getShaderVariant = function (params) {
		var _options$vertex, _options$fragment;
		const programOptions = {
			defines: material.defines,
			pass: params.pass,
			gamma: params.renderParams.shaderOutputGamma,
			toneMapping: params.renderParams.toneMapping,
			vertex: (_options$vertex = options.vertex) != null ? _options$vertex : splatMainVS,
			fragment: (_options$fragment = options.fragment) != null ? _options$fragment : splatMainFS,
			dither: ditherEnum
		};
		const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat);
		const library = getProgramLibrary(params.device);
		library.register('splat', gsplat);
		return library.getProgram('splat', programOptions, processingOptions);
	};
	material.update();
	return material;
};

export { createGSplatMaterial };
